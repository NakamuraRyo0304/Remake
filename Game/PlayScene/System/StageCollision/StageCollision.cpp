/*
 *	@File	StageCollision.cpp
 *	@Brief	ステージの当たり判定。
 *	@Date	2024-02-06
 *  @Author NakamuraRyo
 */

#include "pch.h"
#include "Libraries/UserUtility.h"
#include "StageCollision.h"

// 定数の設定
const float StageCollision::RADIUS = 1.0f;          // 当たり判定を行う半径

// コンストラクタ
StageCollision::StageCollision()
{
}

// デストラクタ
StageCollision::~StageCollision()
{
    m_objects.clear();
}

// 初期化
void StageCollision::Initialize(BlockManager* blocks)
{
    // オブジェクトの追加
    for (auto& obj : blocks->GetFlozens()) m_objects.push_back(obj.get());
    for (auto& obj : blocks->GetClouds())  m_objects.push_back(obj.get());
    for (auto& obj : blocks->GetCoins())   m_objects.push_back(obj.get());
    for (auto& obj : blocks->GetGoals())   m_objects.push_back(obj.get());
    for (auto& obj : blocks->GetSpikes())  m_objects.push_back(obj.get());
    for (auto& obj : blocks->GetLifts())   m_objects.push_back(obj.get());
}

// 更新
void StageCollision::Update(Player* player)
{
    // 操作用プレイヤ座標を保存
    SimpleMath::Vector3 playerPos = player->GetPosition();
    SimpleMath::Vector3 playerScale = player->GetScale() * 2;

    // オブジェクトの判定
    for (auto& obj : m_objects)
    {
        // 非アクティブのオブジェクトはスキップ
        if (not obj->IsActive()) continue;

        if (not UserUtility::CheckPointInSphere(playerPos, RADIUS, obj->GetPosition())) continue;
        auto side = IsCube(&playerPos, obj->GetPosition(), playerScale, obj->GetScale());

        // 固有処理を行う
        PerformEngenProc(player, obj, playerPos, side);
    }
}

// 固有処理
void StageCollision::PerformEngenProc(Player* player, BaseObject* block, SimpleMath::Vector3 newPos, Side side)
{
    // 衝突がなければ処理をしない
    if (side == Side::None) return;

    switch (block->GetID())
    {
        case ID::Obj_Flozen:    // 氷床ブロック
        case ID::Obj_Lift:      // リフトブロック
        {
            // 着地処理を行う
            player->SetFall(side != Side::Up ? true : false);
            player->SetPosition(newPos);
            break;
        }
        case ID::Obj_Cloud:     // 雲ブロック
        {
            // 着地処理を行い、雲を動かす
            static_cast<Cloud*>(block)->SetHitFlag(side != Side::Up ? true : false);
            auto newSide = IsCube(&newPos, block->GetPosition(), player->GetScale(), block->GetScale());
            player->SetFall(newSide != Side::Up ? true : false);
            player->SetPosition(newPos);
            break;
        }
        case ID::Obj_Coin:      // コイン
        {
            // 獲得していなければ獲得処理を行う
            if (not static_cast<Coin*>(block)->IsHit())
            {
                player->CountUpCoins();
                player->SetCoinHit(true);
            }
            static_cast<Coin*>(block)->SetHitFlag(true);
            break;
        }
        case ID::Obj_Goal:      // ゴール
        {
            // ゴール処理を行う
            static_cast<Goal*>(block)->OnHitFlag();
            break;
        }
        case ID::Obj_Spike:     // スパイク
        {
            // スパイクに当たれば死亡させる
            static_cast<Spike*>(block)->SetHitFlag(true);
            player->SetDeath(true);
            break;
        }
        default:
            player->SetFall(true);
            break;
    }
}

//==============================================================================
// 立方体の当たり判定
//==============================================================================
StageCollision::Side StageCollision::IsCube(SimpleMath::Vector3* playerPos, const SimpleMath::Vector3& blockPos,
    const SimpleMath::Vector3& playerScale, const SimpleMath::Vector3& blockScale)
{
    // 衝突面を初期化
    Side side = Side::None;

    // オブジェクトの半径を計算
    float playerRad = std::max({ playerScale.x, playerScale.y, playerScale.z }) * 0.5f;
    float blockRad = std::max({ blockScale.x, blockScale.y, blockScale.z }) * 0.5f;

    // 中心座標の距離を計算
    SimpleMath::Vector3 dist = *playerPos - blockPos;
    SimpleMath::Vector3 distabs = UserUtility::AbsVector3(dist);
    float sumRad = playerRad + blockRad;

    // 距離が半径より小さければ衝突とみなす
    if (distabs.x < sumRad && distabs.y < sumRad && distabs.z < sumRad)
    {
        // どの面に当たったか判定
        SimpleMath::Vector3 overlap = static_cast<SimpleMath::Vector3>(sumRad) - distabs;

        // 当たっている面を判定して押し戻す
        if (std::min({ overlap.x, overlap.y, overlap.z }) == overlap.x)
        {
            side = dist.x > 0 ? Side::Left : Side::Right;
            playerPos->x += dist.x > 0 ? overlap.x : -overlap.x;
        }
        else if (std::min({ overlap.x, overlap.y, overlap.z }) == overlap.y)
        {
            side = dist.y > 0 ? Side::Down : Side::Up;
            playerPos->y += dist.y > 0 ? overlap.y : -overlap.y;
        }
        else
        {
            side = dist.z > 0 ? Side::Behind : Side::Front;
            playerPos->z += dist.z > 0 ? overlap.z : -overlap.z;
        }

        return side;
    }
    else
    {
        // 距離が半径より大きければ衝突面はない
        return Side::None;
    }
}